<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="pt-br" xml:lang="pt-br">
<head>

<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta http-equiv="content-style-type" content="text/css" />
<meta http-equiv="content-language" content="pt-br" />
<meta http-equiv="imagetoolbar" content="no" />
<meta name="resource-type" content="document" />
<meta name="distribution" content="global" />
<meta name="keywords" content="" />
<meta name="description" content="" />
<meta name="robots" content="noindex" />

<title>Ploobs Engine &bull; Exibir tópico - Character jumping behaviour</title>

<link href="./styles/prosilver/theme/print.css" rel="stylesheet" type="text/css" />
</head>

<body id="phpbb">
<div id="wrap">
	<a id="top" name="top" accesskey="t"></a>

	<div id="page-header">
		<h1>Ploobs Engine</h1>
		<p>Ploobs Engine Forum<br /><a href="http://ploobs.com.br/forum/">http://ploobs.com.br/forum/</a></p>

		<h2>Character jumping behaviour</h2>
		<p><a href="http://ploobs.com.br/forum/viewtopic.php?f=4&amp;t=295">http://ploobs.com.br/forum/viewtopic.php?f=4&amp;t=295</a></p>
	</div>

	<div id="page-body">
		<div class="page-number">Página <b>1</b> de <b>1</b></div>
		
			<div class="post">
				<h3>Character jumping behaviour</h3>
				<div class="date"><img src="./styles/prosilver/imageset/icon_post_target.gif" width="11" height="9" alt="Mensagem" title="Mensagem" />Enviado: <strong>25 Abr 2012, 11:13</strong></div>
				<div class="author">por <strong>Treehouse Games</strong></div>
				<div class="content">Hi, <br /><br />We're working on a platformer game and we need to be able to tweak the movement while the character is jumping. First we were using the standard CharacterController, but we couldn't change the jumping behaviour. So now, we have built a custom characterController, characterObject and bepuPhysicsWorld. These are currently all based on the standard code in the engine, that we got from the google repository. <br />We believe we have to change the HandleHorizontalMotion method of the CharacterController, but we don't fully understand what the function of supportLocationVelocity and the supportNormal are. If you could clarify this code a bit, it would help us out alot. <br />We think the solution lies in that code, but we're not entirely sure. If there is another (easier) way to change the jumping behaviour, please let us know.<br /><br /><dl class="codebox"><dt>Código: <a href="#" onclick="selectCode(this); return false;">Selecionar todos</a></dt><dd><code>/// &lt;summary&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; /// Manages movement acceleration, deceleration, and sliding.<br />&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;/summary&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;param name=&quot;supportLocationVelocity&quot;&gt;Velocity of the support point connected to the supportEntity.&lt;/param&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;param name=&quot;supportNormal&quot;&gt;The normal at the surface where the ray hit the entity.&lt;/param&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;param name=&quot;dt&quot;&gt;Timestep of the simulation.&lt;/param&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; private void HandleHorizontalMotion(Vector3 supportLocationVelocity, Vector3 supportNormal, float dt)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (HasTraction &amp;&amp; MovementDirection != Vector2.Zero)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Identify a coordinate system that uses the support normal as Y.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //X is the axis point along the left (negative) and right (positive) relative to the movement direction.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Z points forward (positive) and backward (negative) in the movement direction modified to be parallel to the surface.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector3 x = Vector3.Cross(new Vector3(MovementDirection.X, 0, MovementDirection.Y), supportNormal);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector3 z = Vector3.Cross(supportNormal, x);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Remove from the character a portion of velocity which pushes it horizontally off the desired movement track defined by the movementDirection.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float bodyXVelocity = Vector3.Dot(Body.LinearVelocity, x);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float supportEntityXVelocity = Vector3.Dot(supportLocationVelocity, x);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float velocityChange = MathHelper.Clamp(bodyXVelocity - supportEntityXVelocity, -dt * TractionDeceleration, dt * TractionDeceleration);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Body.LinearVelocity -= velocityChange * x;<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float bodyZVelocity = Vector3.Dot(Body.LinearVelocity, z);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float supportEntityZVelocity = Vector3.Dot(supportLocationVelocity, z);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float netZVelocity = bodyZVelocity - supportEntityZVelocity;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //The velocity difference along the Z axis should accelerate/decelerate to match the goal velocity (max speed).<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (netZVelocity &gt; MaxSpeed)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Decelerate<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; velocityChange = Math.Min(dt * TractionDeceleration, netZVelocity - MaxSpeed);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Body.LinearVelocity -= velocityChange * z;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Accelerate<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; velocityChange = Math.Min(dt * Acceleration, MaxSpeed - netZVelocity);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Body.LinearVelocity += velocityChange * z;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float deceleration;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (HasTraction)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deceleration = dt * TractionDeceleration;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deceleration = dt * SlidingDeceleration;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Remove from the character a portion of velocity defined by the deceleration.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector3 bodyHorizontalVelocity = Body.LinearVelocity - Vector3.Dot(Body.LinearVelocity, supportNormal) * supportNormal;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector3 supportHorizontalVelocity = supportLocationVelocity - Vector3.Dot(supportLocationVelocity, supportNormal) * supportNormal;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector3 relativeVelocity = bodyHorizontalVelocity - supportHorizontalVelocity;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float speed = relativeVelocity.Length();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (speed &gt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector3 horizontalDirection = relativeVelocity / speed;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float velocityChange = Math.Min(speed, deceleration);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Body.LinearVelocity -= velocityChange * horizontalDirection;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /></code></dd></dl></div>
			</div>
			<hr />
		
			<div class="post">
				<h3>Re: Character jumping behaviour</h3>
				<div class="date"><img src="./styles/prosilver/imageset/icon_post_target.gif" width="11" height="9" alt="Mensagem" title="Mensagem" />Enviado: <strong>26 Abr 2012, 22:21</strong></div>
				<div class="author">por <strong>tpastor</strong></div>
				<div class="content">hi,<br /><br />first of all, what behavior you want to achieve ?<br /><br />before changing the functions you mentioned, my advice to you is to change the parameters of the following objects:<br />HorizontalMotionConstraint <br />VerticalMotionConstraint<br />and the properties of the CharacterController.<br /><br />The word &quot;Support&quot; is used to mean the place where the character is in contact with (like the floor,  a wall .....)<br /><br />SupportVelocity is the speed of the entity you are in contact with (maybe the floor is not a static geometry ....)<br />Supportnormal is the normal where the ray with the origin in the character hits the support<br /><br />To help you, here is the function that finds the support for the character (very commented)<br /><br /><dl class="codebox"><dt>Código: <a href="#" onclick="selectCode(this); return false;">Selecionar todos</a></dt><dd><code>&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;summary&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; /// Locates the closest support entity by performing a raycast at collected candidates.<br />&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;/summary&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;param name=&quot;supportEntity&quot;&gt;The closest supporting entity.&lt;/param&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;param name=&quot;supportLocation&quot;&gt;The support location where the ray hit the entity.&lt;/param&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;param name=&quot;supportNormal&quot;&gt;The normal at the surface where the ray hit the entity.&lt;/param&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;param name=&quot;supportDistance&quot;&gt;Distance from the character to the support location.&lt;/param&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; /// &lt;returns&gt;Whether or not a support was located.&lt;/returns&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; private bool FindSupport(out BEPUphysics.Entities.Entity supportEntity, out Vector3 supportLocation, out Vector3 supportNormal, out float supportDistance)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supportEntity = null;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supportLocation = Toolbox.NoVector;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supportNormal = Toolbox.NoVector;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supportDistance = float.MaxValue;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector3 rayOrigin = Body.Position + rayOriginOffset;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; collisionPairCollector.CollisionInformation.Pairs.Count; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var pair = collisionPairCollector.CollisionInformation.Pairs&#91;i&#93;;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Determine which member of the collision pair is the possible support.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Collidable candidate = (pair.BroadPhaseOverlap.EntryA == collisionPairCollector.CollisionInformation ? pair.BroadPhaseOverlap.EntryB : pair.BroadPhaseOverlap.EntryA) as Collidable;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Ensure that the candidate is a valid supporting entity.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (candidate.CollisionRules.Personal &gt;= CollisionRule.NoSolver)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue; //It is invalid!<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //The maximum length is supportHeight * 2 instead of supportHeight alone because the character should be able to step downwards.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //This acts like a sort of 'glue' to help the character stick on the ground in general.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float maximumDistance;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //The 'glue' effect should only occur if the character has a solid hold on the ground though.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Otherwise, the character is falling or sliding around uncontrollably.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (HasTraction)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maximumDistance = supportHeight * 2;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maximumDistance = supportHeight;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RayHit rayHit;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Fire a ray at the candidate and determine some details! <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (candidate.RayCast(new Ray(rayOrigin, Vector3.Down), maximumDistance, out rayHit))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //We want to find the closest support, so compare it against the last closest support.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (rayHit.T &lt; supportDistance)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supportDistance = rayHit.T;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supportLocation = rayHit.Location;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supportNormal = rayHit.T &gt; 0 ? rayHit.Normal : Vector3.Up;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var entityInfo = candidate as EntityCollidable;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (entityInfo != null)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supportEntity = entityInfo.Entity;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supportEntity = null;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supportNormal.Normalize();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return supportDistance &lt; float.MaxValue;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /></code></dd></dl><br /><br />Here is where the jump is calculated<br /><dl class="codebox"><dt>Código: <a href="#" onclick="selectCode(this); return false;">Selecionar todos</a></dt><dd><code>//Attempt to jump.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tryToJump &amp;&amp; StanceManager.CurrentStance != Stance.Crouching) //Jumping while crouching would be a bit silly.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //In the following, note that the jumping velocity changes are computed such that the separating velocity is specifically achieved,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //rather than just adding some speed along an arbitrary direction.&nbsp; This avoids some cases where the character could otherwise increase<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //the jump speed, which may not be desired.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (SupportFinder.HasTraction)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //The character has traction, so jump straight up.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float currentUpVelocity = Vector3.Dot(Body.OrientationMatrix.Up, relativeVelocity);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Target velocity is JumpSpeed.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float velocityChange = Math.Max(jumpSpeed - currentUpVelocity, 0);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ApplyJumpVelocity(ref supportData, Body.OrientationMatrix.Up * velocityChange, ref relativeVelocity);<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Prevent any old contacts from hanging around and coming back with a negative depth.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach (var pair in Body.CollisionInformation.Pairs)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pair.ClearContacts();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SupportFinder.ClearSupportData();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supportData = new SupportData();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (SupportFinder.HasSupport)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //The character does not have traction, so jump along the surface normal instead.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float currentNormalVelocity = Vector3.Dot(supportData.Normal, relativeVelocity);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Target velocity is JumpSpeed.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float velocityChange = Math.Max(slidingJumpSpeed - currentNormalVelocity, 0);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ApplyJumpVelocity(ref supportData, supportData.Normal * -velocityChange, ref relativeVelocity);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Prevent any old contacts from hanging around and coming back with a negative depth.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach (var pair in Body.CollisionInformation.Pairs)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pair.ClearContacts();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SupportFinder.ClearSupportData();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supportData = new SupportData();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</code></dd></dl><br /><br /><br />Apply jump function<br /><dl class="codebox"><dt>Código: <a href="#" onclick="selectCode(this); return false;">Selecionar todos</a></dt><dd><code>void ApplyJumpVelocity(ref SupportData supportData, Vector3 velocityChange, ref Vector3 relativeVelocity)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Body.LinearVelocity += velocityChange;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var entityCollidable = supportData.SupportObject as EntityCollidable;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (entityCollidable != null)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (entityCollidable.Entity.IsDynamic)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector3 change = velocityChange * jumpForceFactor;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entityCollidable.Entity.LinearMomentum += change * -Body.Mass;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; velocityChange += change;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //Update the relative velocity as well.&nbsp; It's a ref parameter, so this update will be reflected in the calling scope.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vector3.Add(ref relativeVelocity, ref velocityChange, out relativeVelocity);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /></code></dd></dl><br /><br />The jump functions do just this:<br />Jumps the character off of whatever it's currently standing on.  If it has traction, it will go straight up.<br />it doesn't have traction, but is still supported by something, it will jump in the direction of the surface normal.</div>
			</div>
			<hr />
		
			<div class="post">
				<h3>Re: Character jumping behaviour</h3>
				<div class="date"><img src="./styles/prosilver/imageset/icon_post_target.gif" width="11" height="9" alt="Mensagem" title="Mensagem" />Enviado: <strong>13 Ago 2013, 03:23</strong></div>
				<div class="author">por <strong>studenthand</strong></div>
				<div class="content">The next time you are up for calvin klein sale on the net shopping, Niceorders will need to definitely be on top rated of your priorities.<br /><br /> <a href="http://www.chooseunderwearonline.com/" class="postlink">Calvin klein underwear sale</a> , Consumers frequently apply perfume on for the inner wrists, as they may be effective pulse points. In the 1990's small time rapper Marky Mark was featured on billboard ads wearing Calvin Klein boxers.<br /><br /> <a href="http://www.underwearlowestprice.com/" class="postlink">Calvin klein underwear australia</a> , Coming to Calvin Klein they have retained a extremely monochromatic and thin garment aesthetic that has translated nicely towards the well-liked spirit of style.Calvin Klein Underwear is amongst the optimum and most reasonably priced lines of menswear you might ever consider.<br /><br /> <a href="http://www.cheapunderwearforsale.com/" class="postlink">Calvin klein underwear</a> , Niceorders also provide ralph lauren, G Star Raw, Dsquared2, D&amp;G,Hackett, Diesel, Abercrombie and lots of even more at outstanding price.<br /><br /> <a href="http://www.calvinkleinireland.com/" class="postlink">Calvin klein underwear cheap</a> , The best aspect is that you don't get a stain in your favorite clothes when you are spraying it on your silky gowns.<br /><br /> <a href="http://www.availableunderwear.com/" class="postlink">Calvin klein underwear online</a> , In addition the colors and the styles which are to be had for men's underwear have augmented the choices that guys have in selecting underwear for themselves.</div>
			</div>
			<hr />
		
	</div>

	<div id="page-footer">
		<div class="page-number">Todos os horários são GMT - 3 horas <br />Página <b>1</b> de <b>1</b></div>
		<div class="copyright">Powered by phpBB&reg; Forum Software &copy; phpBB Group<br />http://www.phpbb.com/</div>
	</div>
</div>

</body>
</html>